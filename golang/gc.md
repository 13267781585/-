# 垃圾回收

## 特点

* 无分代
* 无整理
回收过程不会对对象进行移动和整理
* 并发

## go垃圾回收机制演变

### 1.3前 标记清楚算法

* 整个过程stw
* 存在内存碎片(1.3后引入TC Malloc)

### 1.5 三色标记法+屏障

`大幅度降低垃圾收集的延迟从几百 ms 降低至 10ms 以下`

#### 三色标记法

* 并发标记，不需要stw
* 满足以下条件会导致对象被错误回收：
  * 灰色对象删除了下游的白色对象
  * 删除的白色对象被黑色对象引用

#### 屏障

##### 插入屏障

在A对象引用B对象的时候，B对象被标记为灰色，B对象的内存槽有两种位置：栈和堆。栈空间的特点是容量小，但是要求相应速度快，因为函数调用弹出会被频繁地使用，所以插入屏障机制在栈空间的对象操作中不使用，而仅仅使用在堆空间对象的操作中。因此堆标记结束后需要stw并对栈对象进行重新标记。

##### 删除屏障

`go没有独立实现删除屏障，1.5到1.8是从插入屏障过渡到混合屏障`
被删除的对象，如果自身为灰色或者白色，则被标记为灰色。和插入屏障同理，删除屏障堆栈上的对象不生效，因此在开始标记之前，会stw将所有栈上的对象做快照(标记为黑色，并把引用对象标记为灰色，使得栈上对象处于保护状态下)。

##### 特点

* stw对所有栈扫描，延迟大、不可控

### 1.6 去中心化

* v1.5 版本实现的并发垃圾收集策略由专门的 Goroutine 负责在处理器之间同步和协调垃圾收集的状态。当其他的 Goroutine 发现需要触发垃圾收集时，它们需要将该信息通知给负责修改状态的主 Goroutine，然而这个通知的过程会带来一定的延迟，这个延迟的时间窗口很可能是不可控的，用户程序会在这段时间继续分配内存。v1.6 引入了去中心化的垃圾收集协调机制22，将垃圾收集器变成一个显式的状态机，任意的 Goroutine 都可以调用方法触发状态的迁移，常见的状态迁移方法包括以下几个

  * runtime.gcStart — 从 _GCoff 转换至_GCmark 阶段，进入并发标记阶段并打开写屏障；
  * runtime.gcMarkDone — 如果所有可达对象都已经完成扫描，调用 runtime.gcMarkTermination；
  * runtime.gcMarkTermination — 从 _GCmark 转换_GCmarktermination 阶段，进入标记终止阶段并在完成后进入 _GCoff；
* 使用密集的位图替代空闲链表表示的堆内存，降低清除阶段的 CPU 占用14；

### 1.7 并行栈收缩

* 将垃圾收集的时间缩短至 2ms 以内

### 1.8-1.9 三色标记法+混合屏障

#### 混合屏障

* 混合屏障是插入屏障和删除屏障的结合，优化了删除屏障在开始阶段stw快照栈的缺点，从一次性扫描所有栈到逐个扫描，使得gc过程几乎没有stw。
* 将垃圾收集的时间缩短至 0.5ms 以内

##### 流程

* GC开始将栈上的对象全部扫描并标记为黑色
* GC期间，任何在栈上创建的新对象均为黑色
* 被删除的对象标记为灰色(堆上对象)
* 被删除的对象标记为灰色(堆上对象)

### 1.10 更新垃圾收集调频器

* 分离软硬堆大小的目标?

### 1.13 Scavenger

* 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题

### 1.14 全新的页分配器

* 使用全新的页分配器优化内存分配的速度

## GC整体流程

### 清理终止阶段

* 暂停程序，所有的处理器在这时会进入安全点（Safe point）；
* 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；

### 标记阶段

* 将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
* 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
* 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
* 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
        使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；

### 标记终止阶段

* 暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
        清理处理器上的线程缓存；

### 清理阶段

* 将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
* 恢复用户程序，所有新创建的对象会标记成白色；
* 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

运行时虽然只会使用 _GCoff、_GCmark 和 _GCmarktermination 三个状态表示垃圾收集的全部阶段，但是在实现上却复杂很多，本节将按照垃圾收集的不同阶段详细分析其实现原理。

## GC触发时机

* runtime.GC

* 内存/上次内存回收比例大于`GOGC`配置

* 创建大对象
* 周期性循环(默认两分钟)

## Q&A

### 为什么gogc不使用分代收集器和压缩算法？

go使用tcmalloc内存分配器，不会产生严重内存碎片问题
使用分代收集算法前提：程序中大多数新对象变更更加频繁，因此花更多时间在查看新对象上。不同的是，go编辑器使用逃逸算法分析对象生命周期，并将对象尽可能分配到栈上还不是堆中，所以大部分不被使用的对象直接分配到栈上，分代算法起不到很大作用。
[Go GC](https://studygolang.com/articles/16056)
<https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU>

## 引用

[GO语言原本](https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/)
[Golang 混合写屏障原理深入剖析，这篇文章给你梳理的明明白白！！！](https://blog.csdn.net/CSDN_bang/article/details/107572440)
[7.2 垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)
