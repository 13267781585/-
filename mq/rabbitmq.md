## RabbitMQ
<img src=".\image\1.png" alt="1" />

## 消息可靠性
* 持久化
    * 队列durable(true)
    * 消息durable(true)
    * exchange-deliveryMode=2
* 生产者->exchange
    * 事务
    * 确认机制
* Exchange->queue—exhange路由不到对应的queue
    * 确认机制->mandatory(true)->回退到生产者
    * 备份exchange->备份queue
* queue->consumer
    * 手动确认


## 事务原理
1. 事务的开始 - channel.txSelect: 当客户端发送 txSelect 命令给 RabbitMQ 时，当前通道（Channel）进入事务模式。这意味着随后在该通道进行的所有消息发布都会被挂起，不会被立即发送给交换机。
2. 事务块中的动作： 在一个事务中，你可以发送多个消息。这些消息都不会被立即分发到队列中去。它们会在内存中被收集起来等待事务提交。
3. 事务的提交 - channel.txCommit: 一旦txCommit命令被调用，事务块内所有挂起的动作将会被执行。这包括所有的消息发布和确认。如果所有动作都成功执行，消息将被发往队列。否则，如果任何一步出现错误，会引发异常，并且整个事务会滑入失败状态。
4. 事务的回滚 - channel.txRollback: 如果在事务中的任何时间点调用了txRollback命令，或者在尝试提交事务时发生了错误，当前的事务将被撤销，并且所有挂起的消息发布动作都会被丢弃。
5. 资源锁定： 在事务进行期间，相关的资源（如队列）会被锁定，以确保事务的原子性。也就是说，在并发环境下，其他操作可能会被阻塞直到事务完成，这可能会影响性能。
事务性能差的原因：
1. 同步操作： 当RabbitMQ处理事务时，所有的发送和确认消息操作都是同步完成的。这意味着必须等待网络往返和消息的持久化，在高吞吐量的情况下，这将显著增加消息处理的延迟。
2. 阻塞其他操作： 事务在提交或回滚期间会锁定资源，如相关的队列和交换机。任何其他尝试写入这些资源的操作都将被阻塞，直到事务完成，这会对总体吞吐量产生影响。
3. 磁盘I/O损耗： 为了保持消息的持久性，在事务提交期间，所有消息都必须写入磁盘。频繁的磁盘I/O是成本很高的操作，如果消息量大，将导致性能瓶颈。
4. 不支持批量操作： 事务处理通常涉及到单个消息的写入和确认。与此相比，非事务性的批量消息处理可以更加高效地利用网络和I/O资源。
5. 减低并发度： 事务需要保证操作的原子性，需要在消息写入和确认时进行锁定操作，这会减少消息处理的并发能力。