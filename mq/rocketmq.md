# RocketMQ

## 优势
* 单机吞吐量：十万级
* 可用性：非常高，分布式架构
* 消息可靠性：经过参数优化配置，消息可以做到 0 丢失
* 功能支持：MQ 功能较为完善，还是分布式的，扩展性好
* 支持 10 亿级别的消息堆积，不会因为堆积导致性能下降
* 源码是 Java，方便结合公司自己的业务二次开发
* 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况
* RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ

## 生产者发消息方式
* 同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。
* 异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，当服务器响应时，通过回调函数处理响应。一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。
* 单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。

## 队列-消费者分配方式
### 1. AllocateMessageQueueAveragely（平均分配，默认）
这是默认的队列分配策略。它将尽可能均匀地将消息队列分配给每个消费者。如果队列数不能被消费者数整除，那么某些消费者将会分配到稍微多一点的队列。这种策略适用于大多数情况，尤其是当所有消费者的处理能力相似时。

### 2. AllocateMessageQueueAveragelyByCircle（循环分配）
这种策略通过循环方式分配队列给消费者。它首先确保每个消费者至少分配到一个队列（如果有的话），然后循环方式继续分配剩余的队列。这种方法可以在消费者和队列数量不匹配时，尽量保持分配的公平性。

### 3. AllocateMessageQueueConsistentHash（一致性哈希）
一致性哈希分配策略使用一致性哈希算法来分配队列。这种策略在处理消费者动态变化时非常有用，因为它可以保证大部分队列保持不变，只有少数队列会因为消费者的增加或减少而迁移。这对于状态持久化或者缓存的场景非常有利，因为它减少了因重新分配导致的状态迁移。

### 4. AllocateMessageQueueByConfig（根据配置进行分配）
这种策略允许用户通过配置来手动指定每个消费者应该处理哪些队列。这是一种非常灵活的策略，适用于需要精细控制队列分配的场景，比如某些队列的消息非常重要或特殊处理。

### 5. AllocateMessageQueueByMachineRoom（根据机房）
这种策略根据消费者所在的机房来分配队列。通常用于多机房部署的环境，可以将消息队列尽可能地分配给同一机房内的消费者，从而减少跨机房的数据传输，降低延迟和成本。

### 6. AllocateMachineRoomNearby（就近分配）
就近分配策略尝试将队列分配给地理位置上最近的消费者。这通常用于地理分布广泛的消费者，目的是减少网络延迟和提高消费效率。这种策略需要有明确的地理位置信息，并且需要系统支持根据地理位置进行智能决策。

## 负载均衡
### 生产者
- Producer发送消息时，默认轮询Topic下的所有queue，并采用递增取模的方式往不同的queue上发送消息，以达到让消息平均落在不同的Queue上的目的。而由于queue是分布在不同的Broker上的，所以消息也会发送到不同的Broker上
### 消费者
#### 广播模式（Broadcasting）

在广播模式下，消息被发送到所有订阅了相应主题的消费者。每个消费者都会接收到消息的一个副本，这意味着消息会被完全复制到每一个订阅者那里。

**特点**：
- 每个消费者都独立接收消息，互不影响。
- 适用于需要确保每个消费者都能接收到完全相同消息的场景。

**应用场景**：
- 配置更新：当系统中的配置信息需要更新，并且每个节点都需要同时获取最新配置时。
- 通知广播：比如系统维护通知，需要每个服务节点都能接收到通知。

#### 集群模式（Clustering）

集群模式是 RocketMQ 默认的消息消费模式。在这种模式下，同一个消费组（Consumer Group）中的消费者共同消费同一主题的消息。消息会被分发给消费组中的一个成员，而不是每个成员都接收一份。

**特点**：
- 消息被平均分配给消费组中的每个消费者，实现负载均衡。
- 消费者之间协作，提高消费的效率和速度。

**应用场景**：
- 大数据处理：数据可以被分片处理，提高处理速度。
- 日志收集：日志可以被多个节点分别处理，提高效率。

## 顺序消息
消息发送、存储、消费有序。
### 全局有序
一个queue+consumer
### 局部有序
通过发送到同个queue来实现顺序。

### 导致乱序原因
* rebalance
* 消息重试
* 

## 消息重试
### 方式
集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置。可以有三种配置方式:
- 返回Action.ReconsumerLater(推荐)
- 返回null
- throw new Exception()
### 重试消息如何处理
重试的消息会进入一个%RETRY% + ConsumerGroup的队列中
RocketMQ默认允许每条消息最多重试16次，每次重试的间隔时间如下
重试时间跟延迟消息的延迟级别是对应的。不过取的是延迟级别的后16级别
messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
### 重试次数
- 如果消息重试16次后仍然失败，消息将不再投递，转为进入死信队列
- 一条消息无论重试多少次，这些重试消息的MessageId始终都是一样的
- 关于这个重试次数，RocketMQ可以进行定制。例如通过consumer.setMaxReconsumeTimes(20)，将重试次数设定为20次。当定制的重试次数超过16次后，消息的重试时间间隔均为2小时


## 消息存储
### CommitLog
消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；
### ConsumeQueue
消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；
### IndexFile
IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。

在上面的RocketMQ的消息存储整体架构图中可以看出，RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。

## Rebalance
queue和consumer使用负载均衡算法绑定，queue和consumer数量发生变化都会导致rebalance。
### queue变化
* 运维升级
* 扩容/缩容

### consumer
* 发布升级
* 扩容/缩容

### 影响
- 消费暂停：考虑在只有一个consumer的情况下，其负责消费所有5个队列；在新增consumer，触发Rebalance时，需要分配2个队列给其消费。那么Consumer 1就需要停止这2个队列的消费，等到这两个队列分配给Consumer 2后，这两个队列才能继续被消费。
- 重复消费：Consumer 2 在消费分配给自己的2个队列时，必须接着从Consumer 1之前已经消费到的offset继续开始消费。然而默认情况下，offset是异步提交的，如consumer 1当前消费到offset为10，但是异步提交给broker的offset为8；那么如果consumer 2从8的offset开始消费，那么就会有2条消息重复。也就是说，Consumer 2 并不会等待Consumer1提交完offset后，再进行Rebalance，因此提交间隔越长，可能造成的重复消费就越多。 
- 消费突刺：由于rebalance可能导致重复消费，如果需要重复消费的消息过多；或者因为rebalance暂停时间过长，导致积压了部分消息。那么都有可能导致在rebalance结束之后瞬间可能需要消费很多消息。

## 长轮询
RocketMQ 支持一种称为“长轮询”（Long Polling）的技术，这是一种在消息队列中常用的技术，用于提高消息消费的实时性，同时减少系统资源的浪费。长轮询是消费者从 Broker 拉取消息时使用的一种策略，旨在减少空轮询带来的不必要的网络和 CPU 资源消耗。

### 工作原理

在传统的轮询模式中，消费者会定期向 Broker 发送请求，检查是否有新的消息。如果没有新消息，消费者会立即得到一个空响应，然后过一段时间再次发送请求。这种模式在消息产生不频繁时会导致大量无效的网络请求和资源浪费。

长轮询的工作方式略有不同：

1. **消费者发送请求**：消费者向 Broker 发送拉取请求，请求中通常包含一个超时时间。
2. **检查消息**：Broker 接收到请求后，首先检查是否有可用的消息。
3. **立即返回或等待**：
   - 如果有消息，Broker 立即返回这些消息给消费者。
   - 如果没有消息，Broker 不会立即返回，而是将请求挂起。Broker 会等待直到有新消息到达或超时时间到达。
4. **超时或有消息时返回**：如果在超时时间内有新消息到达，Broker 会立即返回这些消息；如果超时时间到达仍然没有消息，Broker 返回一个空响应。
5. **消费者处理完毕后再次请求**：消费者处理完毕后，根据需要再次发送新的拉取请求。

### 优点

- **减少资源消耗**：长轮询减少了在没有消息时的空轮询，从而降低了网络和 CPU 的无效消耗。
- **提高消息的实时性**：通过长轮询，消费者可以几乎实时地接收到消息，因为一旦有消息可用，Broker 就会立即返回。

### 应用场景

长轮询特别适用于消息的生产不是非常频繁，但对消息延迟敏感的场景。例如，实时通知系统、实时数据处理系统等。