### 二叉树   

1. 前序 中序 后序递归算法   
```java
//前序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    System.out.print(head.value + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

//中序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    preOrderRecur(head.left);
    System.out.print(head.value + " ");
    preOrderRecur(head.right);
}

//后序

public static void postOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    postOrderRecur(head.left);
    postOrderRecur(head.right);
    System.out.print(head.value + " ");
}

```

2. 前序、中序、后序非递归算法   
* 前序  
前序是比较简单的
```java
 public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        List<Integer> outs = new ArrayList<Integer>();
        
        if(root == null)
            return outs;
        nodes.add(root);
        TreeNode n = null;
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.add(n.val);
            if(n.right != null)
                nodes.add(n.right);
            if(n.left != null)
                nodes.add(n.left);
        }
        return outs;
    }
```


* 中序   
先 从根节点左节点遍历到底，然后弹出一个节点判断是否有右节点，再按上述方法可得到结果。
```java
public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        while(n != null || !nodes.isEmpty()){
           while(n != null){
               nodes.add(n);
               n = n.left;
           }
            n = nodes.pollLast();
            outs.add(n.val);
            n = n.right;
            
        }
        
        return outs;
    }
```

* 后序  
后序算法和中序差不多，区别是中序算法在从根节点的左节点遍历到底后，弹出的元素直接取值，而后序算法需要遍历完右子树才能弹出节点取值。(这里还需要一个另外的指针记录最后弹出的节点来判断下一个弹出的节点的右子树是否已经遍历了)


```java
//后序
//算法一：
public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        TreeNode l = null;
        while(n != null || !nodes.isEmpty()){
            //循环到最左子树
            while(n != null){
                nodes.add(n);
                n = n.left;
            }
            
            n = nodes.getLast();
            //如果没有右子树或者右子树已经遍历
            if(n.right == null || n.right == l){
                outs.add(n.val);
                l = nodes.pollLast();       //l指针指向最后出链表的节点，说明该节点已经遍历过
                n = null;
            }else
                n = n.right;
                
        }
        
        return outs;
    }



//算法二
//前序遍历和后序遍历有一定的相似性 前序遍历 根-左-右 后序遍历 左-右-根 所以可以根据前序遍历算法经过改造出可以得到正确结果的后序遍历算法，缺点是遍历的顺便没有按照理论上的顺序(具有一定取巧)

 public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = null;
        TreeNode l = null;
        nodes.add(root);
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.addFirst(n.val);
            if(n.left != null)
                nodes.add(n.left);
            if(n.right != null)
                nodes.add(n.right);
        }
        
        return outs;
    }
```


3. 层次遍历  
*  宽度优先搜索 BFS 
```java
 public List<List<Integer>> levelOrder(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<>();         //存放节点
        ArrayList<List<Integer>> outs = new ArrayList<>();    //存放层次遍历结果
        List<Integer> nums = new ArrayList<>();         //每次层次遍历结果
        if(root == null)
            return outs;
        nodes.add(root);
        
        TreeNode n = null;
        int count1 = 1,count2 = 0;     //两个计数器
        while(count1 > 0){
            
            n = nodes.pollFirst();    
            nums.add(n.val);
            
            //判断是否有左右节点 有则 计算节点的数量 和 加入节点列表
            if(n.left != null){
                nodes.add(n.left);
                count2++;
            }
            if(n.right != null){
                nodes.add(n.right);
                count2++;
            }
            
            //上一层的遍历结束  将count1更新为下一层需要遍历的节点个数 并 将计数器 count2 清零
            if(--count1 == 0){
                count1 = count2;
                count2 = 0;
                outs.add(nums);       //将这层的遍历结果加入到总的列表
                nums = new ArrayList<>();   //每层的遍历结果都需要记录 ，不能简单将局部列表清空，而需要重新申请列表
            }
        }
        return outs;
        
    }
```

* 深度优先遍历(DFS)
```java
//递归
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)   
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}

//迭代
class Solution {
  public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();
    if (root == null) return levels;

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList<Integer>());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i < level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
* 总结   
总的来说，单从代码来看，DFS比较容易理解，代码比较清晰，因为二叉树结构特点的因素，深度遍历比较常见，两者的区别是深度优先遍历 根据 深度 在 List<List<Integer>> levels 中逐层创建好列表，随着各个分支的深入不断加进去，而宽度优先遍历则是每层遍历完成后再将每一层遍历的结果加入到总的数据集。  

4. 运用递归解决问题的两种思路   
* 自顶向下(前序算法)
* 自底向上(后序算法)   

例子：
* 树的深度算法 
* 递归  
```java
  private int deep = 0;
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        treeDeep(root,1);
        return deep;
    }
    
    //自顶向下
    public void treeDeep(TreeNode n, int d){
        if(n == null)
            return;
        if(n.right == null && n.left == null)
            deep = Math.max(deep,d);
        treeDeep(n.left,d + 1);
        treeDeep(n.right,d + 1);
    }
    
```

```java
 public int maxDepth(TreeNode root) {
        return treeDeep(root);
    }
    
    //自底向上
    public int treeDeep(TreeNode n){
        if(n == null)
            return 0;
        int left = treeDeep(n.left);
        int right = treeDeep(n.right);
        return Math.max(left,right) + 1;
        }
    
```
* 迭代   
1. 基于 宽度优先遍历 实现(BFS)
```java
//基于 宽度优先遍历 计算 树的深度
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        
        LinkedList<TreeNode> nodes = new LinkedList<>();
        int deep = 1;
        boolean flag = false;           //因为采用的是宽度优先遍历计算树的深度，同一层有多个节点时计数器只需要加一
        TreeNode n = null;
        int count1 = 1;             //宽度优先算法需要两个计数器，分别计数相邻两层的节点个数，交替循环
        int count2 = 0;
        nodes.add(root);
        while(count1 > 0){
            n = nodes.pollFirst();
            //如果 右节点 或者 左节点 不为空 说明还有下一层 深度计数器加一，并且将 flag 标志 值false 表示这一层的其他节点尽管 右节点 或者 左节点 不为null  深度计数器也不能递增，因为同属于下一层的节点(前面已经加过了)
            if(n.right != null || n.left != null){
                if(!flag)
                    deep++;
                
                flag = true;
            }
            if(n.right != null){
                count2++;
                nodes.add(n.right);
            }
                
            if(n.left != null){
                count2++;
                nodes.add(n.left);
            }
            
            //说明这一层的节点已经遍历完成，将count1 更新 为 count2(下一层的节点个数) 并把标志位置false
            if(--count1 == 0){
                count1 = count2;
                count2 = 0;
                flag = false;
            }
        
        }
        return deep;
    }
    
```
2. 基于 深度优先遍历 实现(DFS)
```java
 //基于 深度优先遍历 计算 树的深度
    //根据 后序 算法 改编
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
       LinkedList<TreeNode> nodes = new LinkedList<>();
        TreeNode n = root;
        TreeNode l = null;
        int count = 0;
        int temp = 0;
        
        while(n != null || !nodes.isEmpty()){
            while(n != null){
                nodes.add(n);
                temp++;
                n = n.left;
            }
            
            n = nodes.getLast();
            if(n.right != null && n.right != l)     //判断该节点是否有右分支
                n = n.right;
            else{
                //没有右分支 或者 右分支已经遍历过
                if(n.right == null && n.left == null)
                    count = Math.max(count,temp);
                l = nodes.pollLast();           //弹出最后一个节点并记录
                temp--;                     //弹出后深度应减一
                n = null;
            }
            
        }
        return count;
    }
    
```

* 总结   
了解递归并利用递归解决问题并不容易。

当遇到树问题时，请先思考一下两个问题：

    你能确定一些参数，从该节点自身解决出发寻找答案吗？
    你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。

转自 https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/3/solve-problems-recursively/11/

5. 判断是否是对称树算法
给定一个二叉树，检查它是否是镜像对称的。

 


```java
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3   

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3

```
* 递归  
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null)
            return true;
        return helper(root.left,root.right);
    }
    
    public boolean helper(TreeNode l, TreeNode r){
        if(l == null && r == null)    //如果 左右子树为null  说明遍历到底了 返回true
                return true;
        else
            if(l == null || r == null)  //如果 左子树有值&&右子树null 或者 右子树有值&&左子树null 说明不对成 返回 false
                return false;
        else
                  //判断对称位置上的数值是否相同
            return l.val == r.val && helper(l.left, r.right) && helper(l.right,r.left);   //递归  一个根节点有两个子树，对应两个位置 所以需要调用两次函数
    }
}
```

* 迭代  
官方解法：
```java
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

6. 路径总和
```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```
* 迭代
1. 基于深度优先遍历算法实现
```java
 //基于深度优先遍历算法实现
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return false;
        
        LinkedList<TreeNode> nodes = new LinkedList<>();
        int count = 0;
        TreeNode n = root;
        TreeNode l = null;
        while(!nodes.isEmpty() || n != null){
            while(n != null){
                nodes.add(n);
                count += n.val;
                n = n.left;
            }
            
            n = nodes.getLast();
            //右子树还没遍历
            if(n.right == null && n.left == null){    //左右子树为空，说明遍历到底，判断是否成立
                if(sum == count)
                    return true;
            }
            else 
                if(n.right != null && n.right != l){       //如果右子树不为null且不等于最后弹出的节点，说明右子树还没有遍历
                    n = n.right;
                    continue;
                }
                               //说明右子树不为空且已经遍历过 或者 右子树为空但不满足题目条件
            l = nodes.pollLast();
            count -= l.val;
            n = null;
            
        }
        return false;
    }
```

2. 基于 宽度优先遍历算法 实现
```java
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    LinkedList<TreeNode> node_stack = new LinkedList();
    LinkedList<Integer> sum_stack = new LinkedList();
    node_stack.add(root);
    sum_stack.add(sum - root.val);

    TreeNode node;
    int curr_sum;
    while ( !node_stack.isEmpty() ) {
      node = node_stack.pollLast();
      curr_sum = sum_stack.pollLast();
      if ((node.right == null) && (node.left == null) && (curr_sum == 0))
        return true;

      if (node.right != null) {
        node_stack.add(node.right);
        sum_stack.add(curr_sum - node.right.val);
      }
      if (node.left != null) {
        node_stack.add(node.left);
        sum_stack.add(curr_sum - node.left.val);
      }
    }
    return false;
  }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

* 迭代  
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return false;
        return helper(root,sum,0);
    }
    
    public boolean helper(TreeNode next, int sum, int count){
        if(next.left == null && next.right == null)
            return sum == (count + next.val);

        return (next.left == null ? false : helper(next.left,sum,count + next.val)) || (next.right == null ? false : helper(next.right,sum,count + next.val));
    }
}

//官方解法
class Solution {
  public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null)
      return false;

    sum -= root.val;
    if ((root.left == null) && (root.right == null))
      return (sum == 0);
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);
  }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

7. 从中序与后序遍历序列构造二叉树  
```
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7


```

* 递归    
思路： 根据后序的遍历规律可以找出树根节点，将 中序遍历序列 分为 左子树中序遍历序列 和 右子树中序遍历序列，再按这种方法一直重复可以构造出一颗完整的树。(需要注意的是在构造过程中因为 后序遍历 是 左-右-根 所以从后序遍历序列最后得到根后，在次得到的根是右子树的根，所以必须反过来先构造右子树在构造左子树)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private HashMap<Integer,Integer> in_value = new HashMap<>(); //中序遍历序列转化为 Map<遍历值，索引>
    private int[] postorder;   //后序遍历序列
    private int pos;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.postorder = postorder;
        this.pos = postorder.length - 1;
        //将中序遍历序列转化为图,便于根据序列值获取该值的索引
        int i = 0;
        for(int t: inorder)
            in_value.put(t,i++);
        
        return helper(0,inorder.length - 1);        
    }
    
    public TreeNode helper(int l, int r){
        if(l > r)
            return null;
        
        int root_value = postorder[pos--];
        TreeNode root = new TreeNode(root_value);
        int index = in_value.get(root_value);
        //必须先构造右子树
        root.right = helper(index + 1, r);
        root.left = helper(l, index - 1);
        return root;
    }
    
}
```

8. 从前序与中序遍历序列构造二叉树  
```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7


```

* 递归 
思路： 和上一题思路相差不多，区别是根据 前序遍历规律 根应该从 前序遍历序列 前往后 找，还有 应该先从 左子树开始构造，在构造 右子树。
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private HashMap<Integer,Integer> in_value = new HashMap<>();
    private int[] preorder;
    private int pos;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.pos = 0;
        int i = 0;
        for(int t: inorder)
            in_value.put(t,i++);
        
        return helper(0,inorder.length - 1);        
    }
    
    public TreeNode helper(int l, int r){
        if(l > r)
            return null;
        
        int root_value = preorder[pos++];
        TreeNode root = new TreeNode(root_value);
        int index = in_value.get(root_value);
        root.left = helper(l, index - 1);
        root.right = helper(index + 1, r);
        return root;
    }
    
}
```

9. 填充每个节点的下一个右侧节点指针
```
给定一个树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

```
![Image](..\image\二叉树9.jpg)

* 基于 广度优先遍历 算法实现
```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/


class Solution {
    //基于 宽度优先遍历 算法实现
    public Node connect(Node root) {
        if(root == null)
            return root;
        
        //需要同时操作两个节点 和 记录相邻层的节点个数
        LinkedList<Node> nodes = new LinkedList<>();
        Node n = null;
        nodes.add(root);

       while(!nodes.isEmpty()){
           int size = nodes.size();
           
           for(int i = 0; i < size; i++){
               n = nodes.pollFirst();
               if(i != size - 1)             //判断是否为这一层最右节点 最右节点next指向null
                   n.next = nodes.getFirst();
               
               if(n.left != null)
                   nodes.add(n.left);
               if(n.right != null)
                   nodes.add(n.right);
           }
       }
        return root;
    }
}
```
