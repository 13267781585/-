### 二叉树   

1. 前序 中序 后序递归算法   
```java
//前序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    System.out.print(head.value + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

//中序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    preOrderRecur(head.left);
    System.out.print(head.value + " ");
    preOrderRecur(head.right);
}

//后序

public static void postOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    postOrderRecur(head.left);
    postOrderRecur(head.right);
    System.out.print(head.value + " ");
}

```

2. 前序、中序、后序非递归算法   
* 前序  
前序是比较简单的
```java
 public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        List<Integer> outs = new ArrayList<Integer>();
        
        if(root == null)
            return outs;
        nodes.add(root);
        TreeNode n = null;
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.add(n.val);
            if(n.right != null)
                nodes.add(n.right);
            if(n.left != null)
                nodes.add(n.left);
        }
        return outs;
    }
```


* 中序   
先 从根节点左节点遍历到底，然后弹出一个节点判断是否有右节点，再按上述方法可得到结果。
```java
public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        while(n != null || !nodes.isEmpty()){
           while(n != null){
               nodes.add(n);
               n = n.left;
           }
            n = nodes.pollLast();
            outs.add(n.val);
            n = n.right;
            
        }
        
        return outs;
    }
```

* 后序  
后序算法和中序差不多，区别是中序算法在从根节点的左节点遍历到底后，弹出的元素直接取值，而后序算法需要遍历完右子树才能弹出节点取值。(这里还需要一个另外的指针记录最后弹出的节点来判断下一个弹出的节点的右子树是否已经遍历了)


```java
//后序
//算法一：
public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        TreeNode l = null;
        while(n != null || !nodes.isEmpty()){
            //循环到最左子树
            while(n != null){
                nodes.add(n);
                n = n.left;
            }
            
            n = nodes.getLast();
            //如果没有右子树或者右子树已经遍历
            if(n.right == null || n.right == l){
                outs.add(n.val);
                l = nodes.pollLast();       //l指针指向最后出链表的节点，说明该节点已经遍历过
                n = null;
            }else
                n = n.right;
                
        }
        
        return outs;
    }



//算法二
//前序遍历和后序遍历有一定的相似性 前序遍历 根-左-右 后序遍历 左-右-根 所以可以根据前序遍历算法经过改造出可以得到正确结果的后序遍历算法，缺点是遍历的顺便没有按照理论上的顺序(具有一定取巧)

 public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = null;
        TreeNode l = null;
        nodes.add(root);
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.addFirst(n.val);
            if(n.left != null)
                nodes.add(n.left);
            if(n.right != null)
                nodes.add(n.right);
        }
        
        return outs;
    }
```


3. 层次遍历  
*  宽度优先搜索 BFS 
```java
 public List<List<Integer>> levelOrder(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<>();         //存放节点
        ArrayList<List<Integer>> outs = new ArrayList<>();    //存放层次遍历结果
        List<Integer> nums = new ArrayList<>();         //每次层次遍历结果
        if(root == null)
            return outs;
        nodes.add(root);
        
        TreeNode n = null;
        int count1 = 1,count2 = 0;     //两个计数器
        while(count1 > 0){
            
            n = nodes.pollFirst();    
            nums.add(n.val);
            
            //判断是否有左右节点 有则 计算节点的数量 和 加入节点列表
            if(n.left != null){
                nodes.add(n.left);
                count2++;
            }
            if(n.right != null){
                nodes.add(n.right);
                count2++;
            }
            
            //上一层的遍历结束  将count1更新为下一层需要遍历的节点个数 并 将计数器 count2 清零
            if(--count1 == 0){
                count1 = count2;
                count2 = 0;
                outs.add(nums);       //将这层的遍历结果加入到总的列表
                nums = new ArrayList<>();   //每层的遍历结果都需要记录 ，不能简单将局部列表清空，而需要重新申请列表
            }
        }
        return outs;
        
    }
```

* 深度优先遍历(DFS)
```java
//递归
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)   
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}

//迭代
class Solution {
  public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();
    if (root == null) return levels;

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList<Integer>());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i < level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
* 总结   
总的来说，单从代码来看，DFS比较容易理解，代码比较清晰，因为二叉树结构特点的因素，深度遍历比较常见，两者的区别是深度优先遍历 根据 深度 在 List<List<Integer>> levels 中逐层创建好列表，随着各个分支的深入不断加进去，而宽度优先遍历则是每层遍历完成后再将每一层遍历的结果加入到总的数据集。  

4. 运用递归解决问题的两种思路   
* 自顶向下(前序算法)
* 自底向上(后序算法)   

例子：
* 树的深度算法 
* 递归  
```java
  private int deep = 0;
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        treeDeep(root,1);
        return deep;
    }
    
    //自顶向下
    public void treeDeep(TreeNode n, int d){
        if(n == null)
            return;
        if(n.right == null && n.left == null)
            deep = Math.max(deep,d);
        treeDeep(n.left,d + 1);
        treeDeep(n.right,d + 1);
    }
    
```

```java
 public int maxDepth(TreeNode root) {
        return treeDeep(root);
    }
    
    //自底向上
    public int treeDeep(TreeNode n){
        if(n == null)
            return 0;
        int left = treeDeep(n.left);
        int right = treeDeep(n.right);
        return Math.max(left,right) + 1;
        }
    
```
* 迭代   
1. 基于 宽度优先遍历 实现(BFS)
```java
//基于 宽度优先遍历 计算 树的深度
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
        
        LinkedList<TreeNode> nodes = new LinkedList<>();
        int deep = 1;
        boolean flag = false;           //因为采用的是宽度优先遍历计算树的深度，同一层有多个节点时计数器只需要加一
        TreeNode n = null;
        int count1 = 1;             //宽度优先算法需要两个计数器，分别计数相邻两层的节点个数，交替循环
        int count2 = 0;
        nodes.add(root);
        while(count1 > 0){
            n = nodes.pollFirst();
            //如果 右节点 或者 左节点 不为空 说明还有下一层 深度计数器加一，并且将 flag 标志 值false 表示这一层的其他节点尽管 右节点 或者 左节点 不为null  深度计数器也不能递增，因为同属于下一层的节点(前面已经加过了)
            if(n.right != null || n.left != null){
                if(!flag)
                    deep++;
                
                flag = true;
            }
            if(n.right != null){
                count2++;
                nodes.add(n.right);
            }
                
            if(n.left != null){
                count2++;
                nodes.add(n.left);
            }
            
            //说明这一层的节点已经遍历完成，将count1 更新 为 count2(下一层的节点个数) 并把标志位置false
            if(--count1 == 0){
                count1 = count2;
                count2 = 0;
                flag = false;
            }
        
        }
        return deep;
    }
    
```
2. 基于 深度优先遍历 实现(DFS)
```java
 //基于 深度优先遍历 计算 树的深度
    //根据 后序 算法 改编
    public int maxDepth(TreeNode root) {
        if(root == null)
            return 0;
       LinkedList<TreeNode> nodes = new LinkedList<>();
        TreeNode n = root;
        TreeNode l = null;
        int count = 0;
        int temp = 0;
        
        while(n != null || !nodes.isEmpty()){
            while(n != null){
                nodes.add(n);
                temp++;
                n = n.left;
            }
            
            n = nodes.getLast();
            if(n.right != null && n.right != l)     //判断该节点是否有右分支
                n = n.right;
            else{
                //没有右分支 或者 右分支已经遍历过
                if(n.right == null && n.left == null)
                    count = Math.max(count,temp);
                l = nodes.pollLast();           //弹出最后一个节点并记录
                temp--;                     //弹出后深度应减一
                n = null;
            }
            
        }
        return count;
    }
    
```

* 总结   
了解递归并利用递归解决问题并不容易。

当遇到树问题时，请先思考一下两个问题：

    你能确定一些参数，从该节点自身解决出发寻找答案吗？
    你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

或者你可以这样思考：对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。

转自 https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/3/solve-problems-recursively/11/

5. 判断是否是对称树算法
给定一个二叉树，检查它是否是镜像对称的。

 


```java
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3   

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3

```
* 递归  
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null)
            return true;
        return helper(root.left,root.right);
    }
    
    public boolean helper(TreeNode l, TreeNode r){
        if(l == null && r == null)    //如果 左右子树为null  说明遍历到底了 返回true
                return true;
        else
            if(l == null || r == null)  //如果 左子树有值&&右子树null 或者 右子树有值&&左子树null 说明不对成 返回 false
                return false;
        else
                  //判断对称位置上的数值是否相同
            return l.val == r.val && helper(l.left, r.right) && helper(l.right,r.left);   //递归  一个根节点有两个子树，对应两个位置 所以需要调用两次函数
    }
}
```

* 迭代  
官方解法：
```java
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

