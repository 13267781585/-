### 二叉树   

1. 前序 中序 后序递归算法   
```java
//前序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    System.out.print(head.value + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}

//中序
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    preOrderRecur(head.left);
    System.out.print(head.value + " ");
    preOrderRecur(head.right);
}

//后序

public static void postOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    postOrderRecur(head.left);
    postOrderRecur(head.right);
    System.out.print(head.value + " ");
}

```

2. 前序、中序、后序非递归算法   
* 前序  
前序是比较简单的
```java
 public List<Integer> preorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        List<Integer> outs = new ArrayList<Integer>();
        
        if(root == null)
            return outs;
        nodes.add(root);
        TreeNode n = null;
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.add(n.val);
            if(n.right != null)
                nodes.add(n.right);
            if(n.left != null)
                nodes.add(n.left);
        }
        return outs;
    }
```


* 中序   
先 从根节点左节点遍历到底，然后弹出一个节点判断是否有右节点，再按上述方法可得到结果。
```java
public List<Integer> inorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        while(n != null || !nodes.isEmpty()){
           while(n != null){
               nodes.add(n);
               n = n.left;
           }
            n = nodes.pollLast();
            outs.add(n.val);
            n = n.right;
            
        }
        
        return outs;
    }
```

* 后序  
后序算法和中序差不多，区别是中序算法在从根节点的左节点遍历到底后，弹出的元素直接取值，而后序算法需要遍历完右子树才能弹出节点取值。(这里还需要一个另外的指针记录最后弹出的节点来判断下一个弹出的节点的右子树是否已经遍历了)


```java
//后序
//算法一：
public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = root;
        TreeNode l = null;
        while(n != null || !nodes.isEmpty()){
            //循环到最左子树
            while(n != null){
                nodes.add(n);
                n = n.left;
            }
            
            n = nodes.getLast();
            //如果没有右子树或者右子树已经遍历
            if(n.right == null || n.right == l){
                outs.add(n.val);
                l = nodes.pollLast();       //l指针指向最后出链表的节点，说明该节点已经遍历过
                n = null;
            }else
                n = n.right;
                
        }
        
        return outs;
    }



//算法二
//前序遍历和后序遍历有一定的相似性 前序遍历 根-左-右 后序遍历 左-右-根 所以可以根据前序遍历算法经过改造出可以得到正确结果的后序遍历算法，缺点是遍历的顺便没有按照理论上的顺序(具有一定取巧)

 public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<TreeNode>();
        LinkedList<Integer> outs = new LinkedList<Integer>();
        
        if(root == null)
            return outs;
        TreeNode n = null;
        TreeNode l = null;
        nodes.add(root);
        while(!nodes.isEmpty()){
            n = nodes.pollLast();
            outs.addFirst(n.val);
            if(n.left != null)
                nodes.add(n.left);
            if(n.right != null)
                nodes.add(n.right);
        }
        
        return outs;
    }
```


3. 层次遍历  
*  宽度优先搜索 BFS 
```java
 public List<List<Integer>> levelOrder(TreeNode root) {
        LinkedList<TreeNode> nodes = new LinkedList<>();         //存放节点
        ArrayList<List<Integer>> outs = new ArrayList<>();    //存放层次遍历结果
        List<Integer> nums = new ArrayList<>();         //每次层次遍历结果
        if(root == null)
            return outs;
        nodes.add(root);
        
        TreeNode n = null;
        int count1 = 1,count2 = 0;     //两个计数器
        while(count1 > 0){
            
            n = nodes.pollFirst();    
            nums.add(n.val);
            
            //判断是否有左右节点 有则 计算节点的数量 和 加入节点列表
            if(n.left != null){
                nodes.add(n.left);
                count2++;
            }
            if(n.right != null){
                nodes.add(n.right);
                count2++;
            }
            
            //上一层的遍历结束  将count1更新为下一层需要遍历的节点个数 并 将计数器 count2 清零
            if(--count1 == 0){
                count1 = count2;
                count2 = 0;
                outs.add(nums);       //将这层的遍历结果加入到总的列表
                nums = new ArrayList<>();   //每层的遍历结果都需要记录 ，不能简单将局部列表清空，而需要重新申请列表
            }
        }
        return outs;
        
    }
```

* 深度优先遍历(DFS)
```java
//递归
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)   
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}

//迭代
class Solution {
  public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();
    if (root == null) return levels;

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.add(root);
    int level = 0;
    while ( !queue.isEmpty() ) {
      // start the current level
      levels.add(new ArrayList<Integer>());

      // number of elements in the current level
      int level_length = queue.size();
      for(int i = 0; i < level_length; ++i) {
        TreeNode node = queue.remove();

        // fulfill the current level
        levels.get(level).add(node.val);

        // add child nodes of the current level
        // in the queue for the next level
        if (node.left != null) queue.add(node.left);
        if (node.right != null) queue.add(node.right);
      }
      // go to next level
      level++;
    }
    return levels;
  }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
* 总结   
总的来说，单从代码来看，DFS比较容易理解，代码比较清晰，因为二叉树结构特点的因素，深度遍历比较常见，两者的区别是深度优先遍历 根据 深度 在 List<List<Integer>> levels 中逐层创建好列表，随着各个分支的深入不断加进去，而宽度优先遍历则是每层遍历完成后再将每一层遍历的结果加入到总的数据集。