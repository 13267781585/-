# BloomFilter

`100w数据只需要2-5M内存`
空间高效概率型数据库，用于判断元素是否在集合中，他可能误判元素在集合中，但是不可能误判元素不在集合中。常用于数据过滤场景。

## 原理

有N个元素，利用K个哈希函数，把这些元素映射到长度为M的位数据上，如果这些位置上都为1，说明元素在(可能)，反之则说明不在。在创建布隆过滤器时，会根据预估的元素+误判率去推算最佳的位数组长度还有哈希函数的数量，计算公式如下：

* 哈希函数的个数=0.7*(M/N)
* 误判率=0.6185^(M/N)
从公式可以看出：
* 位数组越长(M/N)，哈希函数的数据越多
* 位数组越长(M/N)，错误率越低
* 错误率位10%，一个元素需要使用大约5bit空间
* 错误率位1%，一个元素需要使用大约10bit空间
* 错误率位0.1%，一个元素需要使用大约15bit空间

## 大数据量

* 在大数据量场景下，一个布隆过滤器无法承载，可以使用多个，并且使用哈希函数定位具体的过滤器。

## 删除

* 因为布隆过滤器不支持删除的场景，实际应用中，随着时间推移，删除的数据越来越多，布隆过滤器存在的脏数据越多，需要周期性根据全量数据重新生成布隆过滤器。
* Counting BloomFilter
计数布隆过滤器，会记录位置上hash冲突的次数，支持删除操作，需要更多内存开销，比普通布隆过滤器多用3-4倍开销。

## 扩容

* 生成新的布隆过滤器，加载全量数据，扩容过程中如何平滑切换是关键和增量数据的处理是关键
* 增加新的过滤器，使用复合逻辑判断，查询时只要一个过滤器包含就判定存在，插入时顺序判断前序过滤器，只要存在就返回，都不存在插入最后的过滤器(所有过滤器的哈希函数和哈希函数个数都一样，只需要计算一次函数，映射到不同长度的位数组上)

## Q&A

### 布隆过滤器和位图的区别

* 布隆过滤器有误差，需要内存小，位图需要确定数据上下界，是精确表示的，内存开销大
* 都是使用bit去存储二值(有/没有)数据

### 实现

* RedisBloom
  * BF.MADD命令在过滤器不存在情况下会隐私生成，且不带过期时间，可能导致过滤器数据膨胀
