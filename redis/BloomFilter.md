# BloomFilter

`100w数据只需要2-5M内存`
空间高效概率型数据库，用于判断元素是否在集合中，他可能误判元素在集合中，但是不可能误判元素不在集合中。常用于数据过滤场景。

## 原理

有N个元素，利用K个哈希函数，把这些元素映射到长度为M的位数据上，如果这些位置上都为1，说明元素在(可能)，反之则说明不在。在创建布隆过滤器时，会根据预估的元素+误判率去推算最佳的位数组长度还有哈希函数的数量，计算公式如下：

* 哈希函数的个数=0.7*(M/N)
* 误判率=0.6185^(M/N)
从公式可以看出：
* 位数组越长(M/N)，哈希函数的数据越多
* 位数组越长(M/N)，错误率越低
* 错误率位10%，一个元素需要使用大约5bit空间
* 错误率位1%，一个元素需要使用大约10bit空间
* 错误率位0.1%，一个元素需要使用大约15bit空间

## 删除

### 重建

因为布隆过滤器不支持删除的场景，实际应用中，随着时间推移，删除的数据越来越多，布隆过滤器存在的脏数据越多，需要周期性根据全量数据重新生成布隆过滤器。

1. 冗余
使用两个key，插入操作两个都操作，查询时只要有一个存在就代表存在，定时重建一个key，重建过程中增量数据会写入另一个key，不会丢失更新，后续再重建另一个key。

* 缺点

  * 数据冗余

* 优点

  * 平滑重建

2. 增量存储
收集存储过程中增量数据，重建完成后回放。

* 缺点

  * 增量更新操作需要额外处理，容易出错

  * 增量数据有误判风险

* 优点

  * 内存消耗小

### Counting BloomFilter

计数布隆过滤器，会记录位置上hash冲突的次数，支持删除操作，需要更多内存开销，比普通布隆过滤器多用3-4倍开销。

## 扩容

* 生成新的布隆过滤器，加载全量数据，扩容过程中如何平滑切换是关键和增量数据的处理是关键
* 增加新的过滤器，使用复合逻辑判断，查询时只要一个过滤器包含就判定存在，插入时顺序判断前序过滤器，只要存在就返回，都不存在插入最后的过滤器(所有过滤器的哈希函数和哈希函数个数都一样，只需要计算一次函数，映射到不同长度的位数组上)

## 使用模式

### RedisBloom模块

依赖redis提供的bloom功能实现分布式过滤，可以扛住中大型系统流量。

#### 扩展

* 大数据量下使用多个过滤器，用哈希函数做映射到具体过滤器

###

## Q&A

### 布隆过滤器和位图的区别

* 布隆过滤器有误差，需要内存小，位图需要确定数据上下界，是精确表示的，内存开销大
* 都是使用bit去存储二值(有/没有)数据

### 实现

* RedisBloom
  * BF.MADD命令在过滤器不存在情况下会隐私生成，且不带过期时间，可能导致过滤器数据膨胀

### 常用哈希函数

#### FNV

FNV 哈希算法全名为Fowler-Noll-Vo算法，是以三位发明人Glenn Fowler，Landon Curt Noll，Phong Vo的名字来命名的，最早在1991年提出。

* 快速 hash 大量数据并保持较小的冲突率，它的高度分散使它适用于hash一些非常相近的字符串，比如URL，hostname，文件名，text，IP地址等。

#### MurmurHash2

* 速度快
* 哈希冲突少
* 分布均匀：哈希结果在数据分布上非常均匀，可以减少数据被集中存储在某些节点上的情况，从而提高Redis的性能和稳定性。
* 易于实现和使用：实现相对简单，容易理解和使用，适合于大规模的分布式系统。

### 布隆过滤器的缺点

* 维护成本大

* 有误判问题

* Redis实现可能造成热key，大key
