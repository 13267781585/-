# 缓存和db数据一致性
## 策略
### 先写db后删缓存

#### 特点

* 实现简单
* 穿击风险
* 一致性风险(如果db使用的半同步机制，主从延迟情况下，回源读取从库，会有一致性问题，需要bcp对账)

#### 适用场景

* db数据主从强一致性
* 缓存数据是高聚合(更新缓存代价大)

### 先写db后写缓存

#### 特点

* 实现简单
* 一致性好
* 浪费一定性能

#### 适用场景

* 更新缓存数据成本小
* 缓存的是热点数据
* 写少读多

### 先写缓存后写db

#### 特点

* 数据不可靠，以缓存为准
* 读写性能好

### 适用场景

* 数据可靠性要求不高，读写性能要求高

## 案例
### 商品管理系统
#### 角色
* 商家->发商品
* 用户->看商品

#### 技术选型 localcache+redis+db
* 热点发现->[sentinel](https://sentinelguard.io/zh-cn/docs/golang/hotspot-param-flow-control.html)
* 数据库主从同步策略->半同步机制
* 缓存高可用
  * 防击穿->singleflight
  * 防穿透->bitmap
  * 防雪崩->随机过期时间/超时返回
  * 分层限流：接口、db、redis限流
* 缓存db数据一致性策略->先改db后改缓存+mq重试+bcp对账
  * 主动同步：连接主库，一般是商家发品、修改商品
  * 缓存丢失回源：连接从库，一般商品创建到上线，用户查看间隔时间长，足够商品数据主从同步
  * 主动同步操作优先级大于回源(防止并发更新缓存冲突)
  * 主动同步：检查数据是否存在，不存在使用setnx；存在使用version+cas解决并发问题(如果两个更新操作并发产生，一定会有一个失败，可能导致最新的数据没有更新，使用mq重试完成；经过重试后可能老数据覆盖了最新的，使用bcp对账保证最终一致性)；
  * 回源：只使用setnx，失败说明已经有数据，直接返回成功(如果回源操作失败，可能是db数据发生了更新，主动更新读的主库，优先级最高，回源操作直接返回；可能是并发回源操作，读的从库，从库数据同步有延迟，可能不是最新的数据，因为有bcp对账保证最终一致性，所以本次回源也可以直接返回)。

#### 缺点
* 更新缓存原子性：如果需要更新多个redis key，无法保证原子性
* 对账延时：如果缓存有脏数据，bcp对账需要秒级以上才能校正