### Redis面试题整理  

1. Redis相比Memcached有哪些优势?
a.数据类型数量不同，memcached只支持字符串，redis支持多种数据类型，string、hash、list、set、sort set
b.value大小不同，redis最大可以达到1GB，memcached最大只能1MB
c.支持持久化操作，redis支持持久化操作，在突发情况下可以立即恢复数据  
d.底层模型不一样，memcached是多线程，引入了缓存一致性和锁的问题，需要上下文切换和性能损耗，redis是单线程IO多路复用，对于单纯的IO读写操作能把性能发挥到最大，但是在进行集合排序、并集、交集操作时单线程会显示出缺陷。

2. Redis为什么这些快？
a. 纯内存操作  
b. 单线程操作，避免频繁切换上下文
c. 采用 非阻塞IO多路复用机制

题外话：我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

经营方式一

客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题

    几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递

    随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了

    快递员之间的协调很花时间

综合上述缺点，小曲痛定思痛，提出了下面的经营方式

经营方式二

小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

对比

上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

    每个快递员——————>每个线程

    每个快递——————–>每个socket(I/O流)

    快递的送达地点————–>socket的不同状态

    客户送快递请求————–>来自客户端的请求

    小曲的经营方式————–>服务端运行的代码

    一辆车———————->CPU的核数

于是我们有如下结论

1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。
此段摘抄自 <https://www.cnblogs.com/ttaylor/p/9506793.html>

* 总结

**反思这里为什么说单线程比多线程优势大，而通常什么情况下又说多线程比单线程好？**  

**采用多线程或者单线程本质上是为了提高CPU利用率，Java采用多线程是因为在一个线程的操作中，需要CPU计算的时间很短，大部分时间都用在了资源开启或者关闭，为了提高效率，在线程使用完CPU是进行调度，线程的调度也是有开销的，而Redis中单线程更有优势是因为Redis中大部分IO操作都是纳米级别的，也不需要进行其他耗时的操作，所以并不存在CPU被闲置的情况，采用单线程可以避免线程调度带来的花销**

3. redis的过期策略以及内存淘汰机制
分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?

回答:

redis采用的是定期删除+惰性删除策略。

为什么不用定时删除策略?

定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.

定期删除+惰性删除是如何工作的呢?

定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?

不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

在redis.conf中有一行配置

    # maxmemory-policy volatile-lru

该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)

1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。

2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。

3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。

4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐

5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐

6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐

ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。
此段摘抄自 <https://www.cnblogs.com/ttaylor/p/9506793.html>

4. 如何应对缓存穿透和缓存雪崩问题  
a.缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。

解决方案:

(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试,至于锁的类型，单机环境用并发包的Lock类型就行，集群环境则使用分布式锁( redis的setnx).  
集群环境的redis的代码如下所示:

```java


    String get(String key) {  

       String value = redis.get(key);  

       if (value  == null) {  

        if (redis.setnx(key_mutex, "1")) {  

            // 3 min timeout to avoid mutex holder crash  

            redis.expire(key_mutex, 3 * 60)  

            value = db.get(key);  

            redis.set(key, value);  

            redis.delete(key_mutex);  

        } else {  

            //其他线程休息50毫秒后重试  

            Thread.sleep(50);  

            get(key);  

        }  

      }  

    }  

```

(二)如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

* 消耗缓存层大量空间，只能解决多次访问的正常业务请求，如果大量不合理请求攻击，缓存内存会大幅度增长

* 空数据过期后还会打到数据库，数据库压力变大

* 数据一致性问题

(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

b.缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。

解决方案:

(一)给缓存的失效时间，加上一个随机值，避免集体失效。

(二)使用互斥锁，但是该方案吞吐量明显下降了。

(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点

    I 从缓存A读数据库，有则直接返回

    II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。

    III 更新线程同时更新缓存A和缓存B。
此段摘抄自 <https://www.cnblogs.com/ttaylor/p/9506793.html>  

5. 高并发下Redis并发竞争key问题解决方案 **(操作需要按操作执行)**
a. 并发竞争key:当多个redis客户端同时修改同一个key值是，由于redis处理顺序不同使最终的结果不同  
b. 解决方案  
i. 分布式锁+时间戳
**(分布式锁有多种实现方式,例如redis函数是setnx()或者zookeeper等)**
ii. 消息队列
iii. redis中事务的CAS操作？？？

参考资料:
<https://zhuanlan.zhihu.com/p/52756935>
<https://www.cnblogs.com/martinzhang/p/3415204.html>

* 疑问：
a.什么情况下会出现这种问题？
b.加锁和消息队列的意义在哪里？Redis不是单线程执行吗，这里把并行转化为串行有什么意义？(这里时间戳是为了保证顺序执行我可以理解)
