# 事务

## 特性(ACID)

* 原子性
事务中的多个操作具有原子性，要么一起完成，要么一起回滚。
* 一致性
事务提交后数据需要保持一致性/客观规则，多数由于业务属性需要遵循的规则，例如转账前后账户总金额不变等。
* 隔离性
事务之间的执行互不干扰，由于性能原因，分为一下四种隔离级别及可能出现的问题：
  * 读未提交(脏写(两个未提交事务修改同一个数据，一个事务回滚，把另一个事务的数据覆盖)、脏读、不可重复读、幻读)
    * 可以读取到未提交事务的数据
    * 脏读：可以读取到未提交的事务，具有很大不确定性
  * 读已提交(不可重复读、幻读)
    * 可以读取到已提交事务的数据
    * 不可重复读：对同一个数据多次读取结果不同
  * 可重复读(幻读，mysql可以使用锁/当前读+MVCC/快照读避免)
    * 多次读取同一个数据结果相同
    * 幻读：对同一个范围的多次读取返回的条数不同
  * 可串行化
* 持久化
事务一旦提交，造成的修改是持久性的。

## 读已提交是怎么解决脏读/可重复读是怎么解决脏读和不可重读的

MVCC + Read View

### MVCC

<img src=".\image\67.jpg" alt="67" />

### Read View

解决mvcc版本链中哪些版本对当前事务可见的问题，Read View包含以下内容：

* m_ids：当前系统中活跃的读写事务的事务id列表。
* min_trx_id：系统中活跃的读写事务中最小的事务id(m_ids 中的最小值)
* max_trx_id :表示生成 ReadView 时系统中应该分配给下一个事务的id值。
      小贴士:
      注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三 个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，mi n_trx_id的值就是1，max_trx_id的值就是4。
* creator_trx_id :表示生成该 ReadView 的事务的 事务id 。
根据以上四个部分，Read View判断版本是否可见的逻辑如下：
* 如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己 修改过的记录，所以该版本可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生 成 ReadView 前已经提交，所以该版本可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生 成 ReadView 后才开启，所以该版本不可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该 版本不可以被访问;如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。
转载自《MySQL是怎样运行的：从根儿上理解MySQL》

## 读已提交和可重复读模式使用 MVCC + Read View 差异？(怎么解决不可重复读问题)

原因在于Read View的生成时机的不同。

* 读已提交模式下，每次读都会新生成一个新的Read View，所以不同查询的Read View是不同的，会有新提交事物数据变为可见的，因此多次读取同一个数据结果可能是不同的。
* 可重复读模式下，事务查询仅生成一次Read View，因此无论系统事务状态如何转变，后续查询只在这个视图上进行判断，也就解决了不可重读读的问题。

## MVCC + Read View 解决了幻读的问题吗？

解决了一部分幻读，读分为快照读和当前读，MVCC + Read View 解决了快照读的幻读问题，当前读需要使用锁来解决。

* 当前读
读取数据的最新版本
* 快照读
数据存在多个版本，读取的是对当前事务可见的版本
[MVCC真能解决幻读问题吗？](https://www.oo2ee.com/?p=152)

## 事务各个隔离级别下锁的使用

* RU/RC->Record Lock
* RR->Record Lock + Gap Lock + Next-key Lock

## RR模式下怎么解决当前读的幻读问题？

RR模式下加锁基本单位是临键锁，遵循锁粒度最小原则，在一定情况下，退化为间隙锁和行锁。
[心灵拷问：MySQL 到底是怎么加行级锁、间隙锁、临键锁的？](https://blog.csdn.net/w15558056319/article/details/122861509)

## 两阶段提交

`宕机恢复能力+保持磁盘和binlog数据一致性`

### 处理流程

在执行事务中sql语句修改了数据，首先会更改内存中的数据，记录redo log，并把事务状态标记为prepare，在事务提交后，会记录bin log，最后把redo log中事务的状态改为commit，并持久化redo log到磁盘中，后台会有定时线程刷新内存中的脏数据到磁盘，这时redo log中事务日志会被废弃。
<img src=".\image\73.png" alt="73" />

### 宕机恢复过程

* 对于commit状态的事务，刷新脏数据
* 对于prepare状态，可能是在开始写入bin log或者写入完成时间宕机的，需要判断bin log的事务日志是否完整，如果bin log是完整的，修改redo log的事务状态为commit；如果不完整，则回滚事务。

### Q&A

#### 怎么判断binlog是否完整

* statement->commit语句
* row->xid event事件(事务提交事件)
* binlog-checksum(5.6.2)

#### redolog和binlog怎么联系起来

事务有唯一标识符xid
