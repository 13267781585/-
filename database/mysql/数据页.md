## 数据页
Innodb引擎管理存储空间基本单位是页，一个页大小为16kb。

#### 页的类型
页有多种不同的类型，通过File Header(文件头部)中FIL_PAGE_TYPE 去区分。

#### 数据页的结构
![10](.\image\10.jpg)
![14](.\image\14.jpg)
1. File Header(文件头部)
所有页的通用信息，固定占38字节。
![11](.\image\11.jpg)

* FIL_PAGE_SPACE_OR_CHKSUM
页面的校验和，配合File Trailer(文件尾部)用于检测页面同步是否出错。

* FIL_PAGE_TYPE 
页的类型
    1. FIL_PAGE_TYPE_ALLOCATED 最新分配，还没使用
    2. FIL_PAGE_UNDO_LOG Undo 日志页
    3.  FIL_PAGE_INODE 段信息页
    4. FIL_PAGE_IBUF_FREE_LIST Insert Buffer 空闲列表
    5. FIL_PAGE_IBUF_BITMAP Insert Buffer 位图
    6.  FIL_PAGE_TYPE_SYS 系统页
    7.  FIL_PAGE_TYPE_TRX_SYS 事务系统数据
    8. FIL_PAGE_TYPE_FSP_HDR 表空间头部信息
    9. FIL_PAGE_TYPE_XDES 扩展描述页
    10. FIL_PAGE_TYPE_BLOB BLOB 页
    11. FIL_PAGE_INDEX 索引页(数据页)

* FIL_PAGE_PREV 和 FIL_PAGE_NEXT 上一个和下一个页面页号，形成双向链表，实现页面离散存储(页面之间是双向链表关系)。
![12](.\image\12.jpg)


2. File Trailer
所有页的通用信息，用于检测页的同步是否发生差错(断电等导致页面同步不完整)，页面在进行修改时，会先把对应页面加载进内存，修改内存页面后在某个时间同步到磁盘中，在同步之前计算页面校验和，写入头部和尾部，若成功写入则头部尾部校验和一致，若在这个过程中出差，则不一致。这个部分占用8字节：
* 前四个字节代表校验和
* 后四个字节代表页面被最后修改时对应的日志序列位置（LSN）

3. Page Header(页面头部)
数据页独有的部分，记录了页面中存储记录的状态。例如本页中已经存储了多少条记录，第
一条记录的地址是什么，页目录中存储了多少个槽等。占用56字节。
![13](.\image\13.jpg)

4. User Records 和 Free Space 和 Infimum + Supremum
* 记录头信息
![16](.\image\16.jpg)
* InnoDB引擎定义了两条伪记录作为最大记录和最小记录，存放在Infimum + Supremum区域，由五个字节的记录头信息和8字节的固定部分组成(个人理解：为了方便插入和删除不需要考虑头结点和尾节点的问题，方便操作)。
    ![15](.\image\15.jpg)

* 插入记录后会按照设定的行格式从Free Space的空闲区域中申请空间存放记录，存放记录的空间称为User Records   ![17](.\image\17.jpg)
1. 记录头信息(Compact格式)
a. delete_mask
标记是否被删除，被删除的记录因为性能的原因不会立即删除，会形成一个垃圾链表，待回收的空间可以被新插入的记录覆盖。
b. heap_no
表示记录在页中的位置，上图中记录位置为：2、3、4、5，0和1是伪记录的位置。
c. record_type
记录的类型，一共有4种类型的记录， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表
示最小记录， 3 表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的
record_type 值都是 0 ，而最小记录和最大记录的 record_type 值分别为 2 和 3。
d. next_record
表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量，这个属性使得页面内记录形成一个单向链表(页面之间是双向链表)。需要注意的是指针指向的是真实的数据，不是变长列表或者记录头信息，因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变
长字段长度列表、NULL值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率(?)。
e. n_owned
分组后组内最大的记录该字段记录组内记录的数量
![18](.\image\18.jpg)
    

5. Page Directory(页目录)
加快查询纪录的速度，记录在页中以单链表的形式存在，查询效率O(n)，因此需要一个目录表+二分查找算法加快查询效率log(n):
    1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
    2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
    3. 将每个组的最后一条记录的地址偏移量提取出来按顺序存储，页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由 槽 组成的。
![19](.\image\19.jpg)

* 分组规则
对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1-8条之间，剩下的分组中记录的条数只能在4-8 条之间。

* 页内插入记录过程
    1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
    2. 之后每插入一条记录，都会从 页目录 中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
    3. 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在 页目录 中新增一个 槽 来记录这个新增分组中最大的那条记录的偏移量。

* 页内查找数据过程
    1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
    2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

摘抄自 《MySQL是怎样运行的：从根儿上理解MySQL》

#### innodb引擎索引的存储结构
* 非叶子节点的记录record_type 是1(目录项记录)，目录项存放的是关键字和页号，关键字是对应页号中最小关键字。
* 叶子节点存放实际的数据
![20](.\image\20.jpg)
* 查询记录的过程
    1. 不停查找目录项最终得到真实记录存放的页号
    2. 查到页目录定位数据槽
    3. 根据对应数据槽的next_record找到真是记录

#### myisam引擎索引的存储结构
* 非叶子节点的记录record_type 是1(目录项记录)，目录项存放的是关键字和页号，关键字是对应页号中最小关键字。
* 叶子节点存放的是关键字+行号
* 记录和索引分开存放，记录按插入顺序存放

#### 为什么b+树最多3-4层？
假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：
如果 B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。
如果 B+ 树有2层，最多能存放 1000×100=100000 条记录。
如果 B+ 树有3层，最多能存放 1000×1000×100=100000000 条记录。
如果 B+ 树有4层，最多能存放 1000×1000×1000×100=100000000000 条记录。
你的表里能存放 100000000000 条记录么？所以一般情况下，我们用到的 B+ 树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）

